---
outline: deep
---

# Java数据类型

## ArrayList（数据结构 数组）

`ArrayList` 的大小可以动态调整，可以自动扩展以容纳更多元素 。
数组结构的随机访问意味着可以直接通过索引值访问数组中的任何元素，而不受元素顺序的影响。
元素增删慢，查找快。

- 动态数组：当动态数组中的元素数量超过当前容量时，动态数组会自动进行扩容操作，通常是创建一个新的更大的数组，并将原数组中的元素复制到新数组中。
  这样就可以保证动态数组能够灵活地存储任意数量的元素，而不受固定大小的限制。

## LinkedList（数据结构 双向链表）

链表中的元素在内存中并不是连续存储的，而是通过指针将元素连接起来。
双向链表结构每个数据节点中都有两个指针，分别指向直接后继和直接前驱。
所以，从双向链表中的任意一个节点开始，都可以很方便地访问它的前驱节点和后继节点。
方便元素添加、删除的集合。LinkedList集合也可以作为堆栈，队列的结构使用。

## HashSet（数据结构 哈希表）

- 特点：无序、不重复、无索引
  HashSet集合底层采取哈希表存储数据。哈希表是一种对于增删改查数据性能都较好的结构。
  在JDK8之前是数组+链表结构。从JDK8开始是数组+链表+红黑树结构。

1. 创建一个默认长度16，默认加载因子0.75的数组（数组扩容），数组名table。
2. 根据元素的哈希值跟数组的长度计算出应存入的位置
3. 判断当前位置是否为null，如果是nul直接存入
4. 如果位置不为null，表示有元素，则调用equals方法比较属性值
5. 一样：不存. 不一样：存入数组，形成链表
6. JDK8以前：新元素存入数组，老元素挂在新元素下面。JDK8以后：新元素直接挂在老元素下面
7. JDK8以后，当链表长度超过8，而且数组长度大于等于64时，自动转换为红黑树
8. 如果集合中存储的是自定义对象，必须要重写hashCode和equals方法。重写hashCode目的是通过属性值计算hash值。重写equals目的是比较内部属性值，不重写，比较的是地址值

## LinkedHashSet（数据结构 哈希表+链表）

- 特点：有序、不重复、无索引
  这里的有序指的是保证存储和取出的元素顺序一致
- 原理：底层数据结构是依然哈希表，只是每个元素又额外的多了一个双链表的机制记录存储的顺序，添加的时候和上一个添加值建立连接。
  查到遍历的时候是通过双向链表来遍历的。

## TreeSet（数据结构 红黑树）

- 特点：不重复、无索引、可排序（按照元素的默认规则（有小到大）排序。）
- 原理：集合底层是基于红黑树的数据结构实现排序的，增删改查性能都较好

### TreeSet集合默认的规则

- 对于数值类型：Integer，Double，默认按照从小到大的顺序进行排序。
- 对于字符、字符串类型：按照字符在ASCII码表中的数字升序进行排序。

### TreeSet集合自定义排序规则有几种方式

- 方式一：Javabean类实现Comparable接口，指定比较规则。
- 方式二：创建集合时，自定义Comparator比较器对象，指定比较规则。

排序规則：

```java
@Override
public int compareTo（Student o）｛
//指定排序的规则
//只看年龄，我想要按照年龄的升序进行排列
return this.getAge（）-o.getAge（）；
｝
```

- this：表示当前要添加的元素
- o：表示已经在红黑树存在的元素
- 返回值：
    1. 负数：认为要添加的元索是小的，存左边
    2. 正数：认为要添加的元索是大的，存右边
    3. 0： 认为要添加的元系已经存在，含弃

## HashMap（数据结构 哈希表）

- 键特点：无序、不重复、无索引

### HashMap集合底层原理

1. 创建一个默认长度16，默认加载因子0.75的数组（数组扩容），数组名table。
2. put方法将key value存入Entry中。
3. 利用键计算哈希值，跟值无关
4. 添加Entry到数组相应hash索引值下。如果数组hash索引值为null。则直接添加该Entry hash值。将Entry挂在该数组元素下。
5. 新元素挂在老元素下面

### 注意

1. HashMap底层是哈希表结构的
2. 依赖hashCode方法和equals方法保证键的唯一
3. 如果键存储的是自定义对象，需要重写hashCode和equals方法。如果值存储自定义对象，不需要重写hashCode和equals方法

## LinkedHashMap（数据结构 哈希表+链表）

- 键特点：有序（保证存储和取出的元素顺序一致）、不重复、无索引。
### 原理：
底层数据结构是依然哈希表，只是每个键值对元素又额外的多了一个双链表的机制记录存储的顺序

## TreeMap（数据结构 红黑树）

- 键特点：不重复、无索引、可排序（可以对键进行排序）。

### 注意

默认按照键的从小到大进行排序，也可以自己规定键的排序规则

### 两种排序规则

- 实现Comparable接口，指定比较规则。
- 创建集合时传递Comparator比较器对象，指定比较规则。

## 数据类型选择

1. 如果想要集合中的元素可重复：
   用ArrayList集合，基于数组的。（用的最多）
2. 如果想要集合中的元素可重复，而且当前的增删操作明显多于查询：
   用LinkedList集合，基于链表的。
3. 如果想对集合中的元素去重：
   用HashSet集合，基于哈希表的。（用的最多）
4. 如果想对集合中的元素去重，而且保证存取顺序：
   用LinkedHashSet集合，基于哈希表和双链表，效率低于HashSet。
5. 如果想对集合中的元素进行排序：
   用TreeSet集合，基于红黑树。后续也可以用List集合实现排序。

## 哈希值

- 根据hashCode方法算出来的int类型的整数
- 该方法定义在Object类中，所有对象都可以调用，默认使用地址值进行计算
- 一般情况下，会重写hashCode方法，利用对象内部的属性值计算哈希
- 如果没有重写hashCode方法，不同对象计算出的哈希值是不同的
- 如果已经重写hashcode方法，不同的对象只要属性值相同，计算出的哈希值就是一样的
- 在小部分情况下，不同的属性值或者不同的地址值计算出来的哈希值也有可能一样。（哈希碰撞）

## 问题

1. HashSet是利用什么机制保证去重的？ hashcode 和equals方法
2. HashSet为什么没有索引？链表数据结构没法搞索引
3. HashSet为什么存和取的顺序不一样？存的位置是无序的，取得顺序是从头查找，遇到一个链表就从上往下查找。
4. HashSet添加元素的过程？ 先是拿到hash值，找到对应的数组，然后将数据挂到链表下或者红黑树下
5. HashSet集合的底层数据结构是什么样的？ 在JDK8之前是数组+链表结构。从JDK8开始是数组+链表+红黑树结构。