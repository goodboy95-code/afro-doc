---
outline: deep
---

# redis知识点

## 为什么要用缓存

使用缓存的目的就是提升读写性能。
在实际的业务场景下，更多的是为了提升读性能，带来更好的性能和并发量。
Redis的读写性能比MySQL好的多，我们就可以把MySQL中的热点数据缓存到Redis，提升读取性能，同时减轻了MySQL的读取压力。

## 什么是Redis

Redis是一个高性能的内存数据存储系统，也可以称为键值存储系统。
它支持多种数据结构，包括字符串、哈希、列表、集合、有序集合等。
还提供了一些高级功能，如发布订阅、事务、Lua脚本等。
Redis的特点是数据存储在内存中，可以快速读写，同时支持数据持久化到磁盘中。
Redis还具有分布式特性，可以通过分片和复制来实现高可用和高扩展性。

## 使用Redis有哪些好处

1. 高性能：Redis将数据存储在内存中，读写速度非常快，可以达到几十万甚至上百万QPS，特别适合高并发场景。
2. 数据结构丰富：Redis支持多种数据结构，如字符串、哈希、列表、集合、有序集合等，可以满足不同场景下的需求。
3. 持久化：Redis支持将数据持久化到磁盘中，以保证数据的安全性和可恢复性。
4. 分布式特性：Redis支持分片和复制，可以实现高可用和高扩展性，支持数据在多台服务器之间的共享。
5. 丰富的功能：Redis提供了许多高级功能，如事务、Lua脚本、发布订阅、过期策略等，可以满足更加复杂的业务需求。

### Redis的发布订阅

Redis的发布订阅是一种消息传递机制，允许客户端订阅一个或多个频道，并接收该频道上发布的消息。
当有消息发布到频道时，所有订阅该频道的客户端都会收到该消息。

### Redis事务

Redis中的事务是一组命令的集合，是Redis的最小执行单位。
它可以保证一次执行多个命令，每个事务是一个单独的隔离操作，事务中的所有命令都会被序列化、按顺序地执行，服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断。
Redis事务通过MULTI、EXEC、DISCARD、WATCH等命令来实现的。

| 命令      | 作用                                        |
|---------|-------------------------------------------|
| MULTI   | 开启一个事务                                    |
| EXEC    | 提交事务，从命令队列中取出提交的操作命令，进行实际执行               |
| DISCARD | 放弃一个事务，清空命令队列                             |
| WATCH   | 检测一个或多个键的值在事务执行期间是否发生变化，如果发生变化，那么当前事务放弃执行 |

#### Redis事务特点

1. 一次性：事务中的所有命令都会被按顺序地执行，服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断，直到事务命令全部执行完毕才会执行其他客户端的命令。
2. Redis事务是不支持回滚的。（即使在使用MULTI和EXEC命令包裹多个Redis命令时，如果其中任何一个命令执行失败，Redis不会回滚已经执行的命令，而是继续执行后续的命令。）
3. Redis事务中，如果某个命令执行失败，那么其他命令仍然会被执行。
4. Redis事务是原子的，即要么全部执行，要么全部不执行。但是执行失败也算执行。

### Redis中的Lua脚本

Redis中的Lua脚本是一种嵌入式脚本语言，它允许用户在Redis中执行自定义的脚本，以实现更复杂的逻辑和功能。
执行整个 Lua 脚本的过程中，不会有其他 Redis 命令插入执行。

### 分片和复制

- 分片：将数据分散存储在多个节点上，以提高性能和可伸缩性。
- 复制：配置Redis主从复制，将一个Redis实例作为主节点，其他实例作为从节点。通过配置主从复制，可以实现数据的备份和故障恢复。

### 高可用和高扩展性

Redis的高可用是指Redis系统在出现故障时，仍然能够提供服务的能力。
Redis的高扩展性是指Redis系统能够根据业务需求，动态地增加或减少服务器数量，以满足不同的业务需求。

### Redis的过期策略以及内存淘汰机制

过期策略：

- 定时删除：在设置key过期的同时，创建一个定时器，当过期时间到达时，就会立即删除该key。
- 惰性删除：再获取某个key的值时，先检查该key是否过期，如果过期就删除，否则返回该key的值。 Redis默认使用惰性删除策略。

内存淘汰机制

- noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。
- allkeys-lru：当内存不足以容纳新写入数据时，删除最近最少使用的key。Redis默认的淘汰策略。
- allkeys-random：当内存不足以容纳新写入数据时，随机删除某个key。
- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的key中，删除最近最少使用的key。
- volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的key中，随机删除某个key。
- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的key中，删除存活时间（TTL）最短的key。

## Redis线程模型

Redis采用单线程模型，也就是说所有的请求都由同一个线程来处理。
这个线程主要负责网络IO、请求解析、命令执行和数据返回等业务。
Redis内部通过事件驱动机制来实现异步IO操作，包括文件事件和时间事件。
具体来说，Redis在启动时会创建一个事件处理器，来监听客户端套接字的读写事件，并在事件发生时触发响应的回调函数来处理事件。

::: tip
Redis的单线程模型并不是说只有一个线程在运行，而是指所有的业务逻辑都由同一个线程来处理。
Redis内部仍然有多个线程在运行，例如用于定时任务、AOF重写等操作的后台线程。

事件驱动是一种编程范式，其中程序的执行流程由事件的发生和处理来驱动。
在事件驱动编程中，程序会监听各种事件（如用户输入、网络请求、定时器触发等），并在事件发生时执行相应的处理逻辑。
这种模型使得程序可以异步地响应事件，而不需要阻塞等待事件的发生。
:::

## 为什么Redis单线程模型效率也能那么高？

1. C语言实现，效率高
2. 纯内存操作
3. 基于非阻塞的IO复用模型机制
4. 单线程的话可以避免多线程的频繁上下文切换问题
5. 丰富的数据结构，全程采用哈希结构，读取速度非常快，对数据存储进行了一些优化，例如压缩表、跳表等。

::: tip
压缩表：
Redis的压缩表是一种用于存储大量键值对的数据结构，它通过将多个键值对压缩成一个大的键值对来减少内存占用。
压缩表内部使用了一个哈希表，每个键值对都存储在哈希表的一个桶中。
:::

## 为什么Redis需要把所有数据放到内存中？

Redis之所以将所有数据都放在内存中，是因为它设计的目标是高性能、高吞吐量和低延迟，而内存访问的速度比磁盘访问的速度快很多。
如果数据存储在硬盘中，磁盘I/O会严重影响Redis的性能。
而且Redis还提供了数据持久化功能，不用担心服务器重启对内存中数据的影响。

## Redis的同步机制

Redis支持主从同步和从从同步，而在进行第一次主从同步时，需要现在主节点上执行BGSAVE命令，将当前内存中的数据持久化道磁盘上生成RDB文件，并且主节点需要将后续修改操作记录到内存缓冲区中。在这个过程中，主节点会将生成的RDB文件发送给从节点，从节点接收并加载RDB文件到自己的内存中。
加载完成后，从节点会通知主节点，将主节点在复制期间产生的命令同步到从节点，以此完成主从同步过程。

## pipeline有什么好处

使用Pipeline的好处在于可以将多次I/O往返的时间缩短为一次，从而提高Redis的吞吐量和性能。
Pipeline允许客户端将多个Redis命令打包成一次请求发送给Redis服务器，Redis服务器收到后，将多个命令按顺序执行，并将执行结果按照请求的顺序一次性返回给客户端。

## Redis优点和缺点

## Redis缓存刷新策略

1. 基于过期时间：可以设置key的过期时间，当过期时间到达后，Redis会自动删除该key。
2. 基于LRU算法：Redis使用LRU算法来淘汰最近最少使用的key，以保留热点数据。
3. 基于LFU算法：Redis使用LFU算法来淘汰最不经常使用的key，以保留热点数据。
4. 基于手动刷新：可以手动删除缓存中的key。

## Redis持久化方式有哪些？有什么区别？

Redis提供两种持久化机制：RDB和AOF。

RDB(Redis DataBase)持久化：会将Redis在内存中某个时间点上的数据快照保存到磁盘上，形成一个RDB文件。

优点：

- 只有一个dump.rdb文件，方便持久化。
- 容灾性好，可以独立保存。
- 性能最大化，fork子进程来完成写操作，让主进程继续处理命令，I/O最大化
- 数据集较大时，比AOF的启动效率更高。

缺点：
数据安全性较低，RDB是间隔一段时间进行持久化，如果持久化之间Redis发生故障，会发生数据丢失。

AOF(Append Only File)持久化：是将Redis写操作记录到一个AOF文件中，每次Redis执行一条写命令，就将该命令写入AOF文件中，这样可以保证每条命令都能被保存下来。
AOF文件可以进行追加和重写操作，当文件太大时，Redis会自动进行重写，将多次修改合并成一条，以减少磁盘占用空间。

优点：

数据安全：AOF持久化可以配置append fsync属性，它可以指定AOF文件的刷盘策略。

- 默认值为every sec。即每秒中将AOF缓存中的数据写入磁盘一次。
- always。立即将AOF缓存中的数据写入磁盘。
  Redis发生异常，只要AOF文件中已经记录了相应的写操作，就可以通过AOF文件来恢复数据。

数据一致性：AOF持久化是通过append模式写入文件的，即每次写操作都是追加到AOF文件末尾。
因此，即使Redis在写入AOF文件的过程中宕机，AOF文件也不会损坏，而是只会丢失一部分的数据。
可以通过重放日志来恢复数据。

需要注意的是，使用AOF持久化时，如果Redis频繁执行写操作，那么AOF文件可能会非常大，可能影响性能。
因此，用户可以通过配置AOF重写规则，定期对AOF文件进行压缩，以减小文件大小。

缺点：

1. AOF文件比RDB文件大，且恢复速度慢。
2. 数据集较大时，比RDB启动效率低。
3. Redis支持同时使用RDB和AOF持久化机制。

## 持久化有两种，如何选择？

使用AOF持久化来记录Redis执行的所有写操作，并将RDB持久化用于冷备。
如果仅使用AOF进行冷备，那么在恢复数据时，它可能会比RDB持久化慢。
如果只使用AOF持久化，那么可能会因为AOF文件过大导致性能下降。
使用AOF持久化可以保证数据不丢失，并作为数据恢复的首选，使用RDB持久化作为冷备，以提供快速数据恢复选项。
如果同时使用RDB和AOF持久化机制，在Redis重启时，会使用AOF来重构数据，因为AOF中的数据更加完整。

## 怎么使用Redis实现消息队列？

## Redis为什么设计成单线程的

Redis单线程的设计思想主要是为了避免多线程带来的上下文切换、锁竞争等开销。从而提高Redis的效率和性能。

## 什么是Big key？会存在什么影响？

## Redis常见性能问题和解决方案

## 如果Redis中有1亿个key，其中有10w个key是以某个固定的已知前缀开头的，如何将它们全部找出来？

## 如果有大量的key需要设置同一时间过期，一般需要注意什么？

如果大量缓存同时失效，会导致大量的请求直接访问数据库，容易造成数据库崩溃或者降低数据库的性能，进而影响整个系统的稳定性。
为了预防这种情况的发生，我们最好在设计数据过期时间的时候，都加上一个随机值，让过期时间更加分散，从而尽量避免大量的key在同一时刻失效。

## 什么情况下可能会导致Redis阻塞？

- AOF 持久化
  如果配置了AOF并且设置为每个写命令都同步到磁盘（appendfsync always），这可能会导致每个写操作都需要等待磁盘写入完成，从而引起阻塞。
- 长时间运行的命令
  如果Redis执行了长时间运行的命令，例如keys *，这可能会导致Redis阻塞，直到命令执行完成。
- RDB 快照
  在创建 RDB 快照时，如果使用了 SAVE 命令，Redis 会阻塞所有客户端请求直到快照完成。虽然 BGSAVE
  命令可以在后台进行快照保存，但在快照开始的瞬间仍可能会有短暂的阻塞。
- 大量客户端连接
  如果 Redis 服务器处理的客户端连接数过多，可能会因为网络 I/O 或线程处理能力达到限制而导致阻塞。
- Lua 脚本执行
  执行 Lua 脚本时，Redis 会锁定执行，直到脚本执行完成。如果脚本执行时间过长，会阻塞其他命令的执行。
- 键过期
  如果 Redis 中有大量的键在同一时间过期，可能会导致 Redis 阻塞，因为 Redis 需要逐个删除过期的键。
- 内存交换
  如果 Redis 内存使用量过高，操作系统可能会尝试使用交换分区来释放内存，将内存中的数据移动到硬盘上的交换空间（swap space）中，以便为其他需要内存的进程腾出空间。这会导致 Redis 性能下降，并可能引起阻塞。
- 网络问题
  网络延迟或不稳定也可能导致客户端感知到的 Redis 阻塞，尤其是在分布式部署中。

## 为什么RDB快照有bgsave可以在后台执行，而AOF 持久化没有
- RDB 快照

RDB 快照是通过创建数据集的完整副本来工作的。
BGSAVE 命令启动一个子进程来生成快照文件，这个子进程将当前内存中的数据集写入硬盘。
这种方式允许主进程继续处理客户端请求，而不会被阻塞，因为子进程是通过操作系统的写时复制（copy-on-write, COW）技术来访问数据的，这意味着主进程和子进程共享相同的内存页，直到主进程尝试修改数据，此时才会为主进程创建私有的内存页。
- AOF 持久化

AOF 持久化则是记录每个写操作命令，将这些命令追加到 AOF 文件的末尾。AOF 的设计目的是为了提供一种可以实时记录操作的持久化方式，确保数据的完整性和一致性。如果将 AOF 的写入操作放在后台进程中，主进程和后台进程之间必须同步命令日志，这不仅会增加复杂性，还可能引入延迟和一致性问题。例如，如果后台进程在追加命令到 AOF 文件时落后于主进程，可能会导致数据恢复时的状态与实际操作时的状态不一致。
此外，AOF 文件的追加操作通常很快，因为它只涉及向文件末尾写入数据，而不需要读取或处理整个数据集。因此，即使这些操作在主线程中执行，通常也不会引起显著的性能问题，特别是当合理配置 appendfsync 选项（如设置为 everysec）时，可以平衡性能和数据安全性。
总之，RDB 通过 BGSAVE 允许后台执行快照保存，而 AOF 持久化则直接在主线程中追加命令，这是基于它们的设计理念和对性能及数据一致性要求的不同考虑。

## 怎么提高缓存命中率

- 预热缓存：在系统启动的时候，将一些热点数据提前加载到缓存中，可以避免在系统运行时出现缓存穿透和缓存雪崩的情况。
- 增加缓存容量：增加缓存容量可以缓存更多的数据，从而提高缓存命中率。
- 优化缓存设计：合理的缓存设计是提高缓存命中率的前提，包括选择合适的数据结构、缓存过期时间、缓存的key命名等。
- 使用多级缓存：多级缓存可以将热点数据缓存在更快速、容量更小的缓存中，减少从慢速缓存或者数据库中读取数据的次数。
- 缓存穿透处理：针对一些缓存中不存在，但是经常被查询的数据，可以采取布隆过滤器或设置空值等方式来进行预判，避免缓存穿透的情况。
- 建立读写分离的架构：将读请求和写请求分别处理，读请求可以直接从缓存中读取数据，写请求更新数据库后再更新缓存，从而避免缓存和数据库的一致性问题。

## Redis如何解决key冲突

使用业务名和参数来区key。

## 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级？

- 缓存雪崩：指在某个时间段内缓存集体过期失效或缓存服务重启，导致大量请求都落到数据库上，从而导致数据库崩溃的情况。
- 缓存穿透：是指查询一个数据库中不存在的数据，由于缓存中没有，导致请求都落到数据库上，从而导致数据库崩溃的情况。
- 缓存预热：是指在系统上线前，将可能需要的数据提前加载到缓存中，以提高缓存的命中率。
- 缓存更新：是指当数据更新时，同时更新缓存中的数据，以保证缓存和数据库中的数据一致性。
- 缓存降级：是指当缓存不可用时，系统能够自动切换到备份数据源，以保证系统能够正常运行。

### 常见的Redis缓存降级策略

- 熔断降级：当Redis缓存故障或者超时时，系统会进入熔断状态，所有请求转发到备用服务。
- 限流降级：当Redis缓存无法处理所有请求时，系统会采用限流策略，限制访问流量，保护系统资源，避免系统崩溃。
- 数据降级：当Redis缓存故障时，系统可以返回默认值，避免因缓存故障导致业务受损。

## 热点数据和冷数据

热点数据：是指那些被频繁访问的数据，通常这些数据是用户最常访问的数据，因此需要被快速地访问到。
冷数据：是指那些被很少访问的数据，通常这些数据是用户很少访问的数据，因此不需要被快速地访问到。

### 热点数据和冷数据的处理策略

对于热点数据需要采用缓存预热、缓存更新等策略来保证缓存的命中率，而对于冷数据则可以采用懒加载等策略来避免不必要的缓存开销。

## 为什么Redis的操作是原子性的，怎么保证原子性

客户端原子性：客户端需要确保在发送命令时不会被其他客户端的命令中断，可以使用MULTI和EXEC命令来确保原子性。

服务器原子性：事务（单条命令事务和multi/exec事务）和Lua脚本。

在事务中，Redis会将多个命令打包成一个事务进行执行，事务中的所有命令都会在一次操作中被执行，要么全部执行成功，要么全部不执行。
执行失败也算执行。

而Lua脚本则可以将多个操作打包成一个原子性的操作进行执行，这个操作要么全部执行成功，要么全部不执行。
## 布隆过滤器

布隆过滤器主要是用于检索一个元素绝对不在集合中或可能在集合中。
它的底层主要是先去初始化一个比较大的数组，里面存放二进制的0或1，初始值都是0，然后把获取数据的key经过3个哈希函数的计算，模于数组长度找到数据的下标，然后把下标位置的值0改为1，这样的话，三个数组下标的位置就能标明一个key的存在。
查找时必须三个hash对应的下标对应的值都是1。

布隆过滤器可能存在一些误判，因为哈希冲突不可能避免，所以这个误判是必然存在的，增加数组长度或者增加hash个数可以降低误判。
