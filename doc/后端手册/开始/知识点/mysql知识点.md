---
outline: deep
---

# mysql知识点

## MySQL常用引擎InnoDB和MyISAM比较

InnoDB是MySQL的默认存储引擎。
它支持事务、行级锁和外键约束等特性，适用于需要高并发、高可靠性、高可用性和数据安全性的应用场景。

MyISAM是MySQL的另一个常见的存储引擎，它不支持事务和行级锁，但是支持全文检索和压缩包（MyISAM压缩包是一种将MyISAM数据文件和索引文件压缩到一个文件中的方法，这样可以减少磁盘空间占用，提高查询性能。）等特性，适用于读密集、写少的应用场景。

- 事务和锁：InnoDB支持事务和行级锁，而MyISAM不支持事务，只支持表级锁。
  因此在高并发的场景下，InnoDB可以提供更好的并发性能和数据一致性，而MyISAM的锁机制可能会导致读写冲突和性能问题。

- 索引：InnoDB的索引是B+树索引，而MyISAM的索引是B树索引。
  B+树索引对于范围查询和排序等操作的性能更好，而B树索引对于等值查询的性能更好。

- 全文检索：MyISAM支持全文检索，而InnoDB不支持全文检索。如果需要进行全文检索，可以使用MySQL的全文检索引擎(如Sphinx)，
  或者使用其他支持全文检索的数据库。

- 外键约束：InnoDB支持外键约束，而MyISAM不支持外键约束。使用外键约束可以保证数据的完整性和一致性，避免数据异常和错误。

- 数据安全性：InnoDB支持崩溃恢复和数据恢复，可以保证数据的安全性和完整性。而MyISAM不支持崩溃恢复和数据恢复，一旦发生崩溃，可能会导致数据丢失或不一致。
  InnoDB不保存表的具体行数，执行SELECT COUNT(*) FROM table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快。

## 数据库事务

数据库事务是指一系列数据库操作被视为一个单独的逻辑单元，要么全部成功执行，要么全部失败回滚。
事务的目的是确保数据的完整性和一致性，即使在多个并发访问的情况下也保证数据的正确性。
在数据库中，事务通常由以下四个属性组成，即ACID:

- 原子性(Atomicity)：事务是一个原子操作，要么全部执行，要么全部回滚，不存在部分执行的情况。
- 一致性(Consistency)：事务执行前后，数据库中的数据必须满足约束条件和完整性规则，即数据库中的数据必须处于一致的状态。
- 隔离性(Isolation)：多个事务并发执行时，每个事务都应该感觉不到其他事务的存在，每个事务的执行应该独立于其他事务的执行。
- 持久性(Durability)：一旦事务执行成功，它对数据库的修改应该是永久性的，即使发生系统故障或重启，数据库也应该能够恢复到事务执行成功的状态。
- 通过使用事务，可以确保数据库操作的原子性和一致性，避免数据异常和错误。

MySQL中的事务处理是遵循ACID原则的，其中包括原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。
在事务中的操作（如INSERT、UPDATE、DELETE等）会在事务开始后逐个执行，但这些变更在事务提交（COMMIT）之前对其他事务是不可见的。
简单来说，事务中的SQL命令是一个一个执行的，但只有在执行COMMIT命令后，这些变更才会被永久保存，并对其他用户或事务可见。
如果事务中途发生错误或者执行ROLLBACK命令，那么事务中的所有操作都会被撤销，恢复到事务开始前的状态。

## 数据库索引

索引是一种特殊的数据结构，用于加快数据库中数据查询的速度。它类似于书中的目录，可以帮助快速查找特定的数据。
在数据库中，索引通常是在表的一列或多列上创建的。
创建索引后，数据库会使用类似于二分查找的算法来查找数据，从而大大提高了数据查询的速度。
索引可以大大提高数据查询的速度，但也会增加数据修改的时间和磁盘空间的使用。
因此，在选择索引时，需要根据实际情况进行权衡。
一般来说，应该对经常用于查询的列或用于表之间连接的列创建索引，同时避免创建过多的索引和不必要的索引，以免对数据库性能产生负面影响。

### 索引分类

1. 主键索引（Primary Key Index）：主键索引是一种唯一索引，它的值必须唯一，且不能为NULL。每个InnoDB表都必须有一个主键索引，如果没有显式指定，InnoDB会自动选择一个唯一的非空列作为主键。
2. 唯一索引（Unique Index）：唯一索引的值必须唯一，但可以有NULL值。一个表可以有多个唯一索引。
3. 普通索引（Normal Index）：普通索引是最基本的索引，它没有任何限制。
4. 全文索引（Full-Text Index）：全文索引是一种特殊的索引，用于全文搜索。它只能用于MyISAM表，InnoDB表不支持全文索引。
5. 空间索引（Spatial Index）：空间索引是一种特殊的索引，用于处理空间数据。它只能用于MyISAM表，InnoDB表不支持空间索引。
6. 组合索引（Composite Index）：组合索引是指在多个列上创建的索引，可以提高查询效率。例如，如果你经常在name和age两个列上进行查询，那么在这两个列上创建一个组合索引可能会比在每个列上创建单独的索引更有效。
7. 前缀索引（Prefix Index）：前缀索引是指在索引的列上只索引列值的一部分。例如，如果你在一个VARCHAR(100)
   列上创建一个前缀长度为10的索引，那么这个索引只会包含这个列值的前10个字符。
   覆盖索引（Covering Index）：覆盖索引是指一个索引包含了所有需要的查询字段，这样查询就不需要访问表的数据行，只需要访问索引就可以完成查询。
   MySQL的最左前缀原则是指在使用多列索引时，只有最左边的列可以被用来进行索引扫描。这意味着，如果你有一个索引包含了(A, B, C)
   三列，那么只有(A)或(A, B)或(A, B, C)的前缀可以被用来进行索引扫描。

### 隐藏索引

在MySQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，又只能
通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。
从MySQL 8.x开始支持隐藏索引 ，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引(即使使用force index(
强制使用索引)
，优化器也不会使用该索引)，确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。

:::tip
注意:当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。
:::

## 索引有什么缺点

1. 存储空间：索引需要额外的存储空间。对于大型表，索引可能会占用大量磁盘空间。
2. 维护开销：每当对表进行插入、更新或删除操作时，索引也需要相应地更新。这会增加数据库的维护开销，影响写操作的性能。
3. 插入速度变慢：由于每次插入新数据时都需要更新索引，插入操作的速度会变慢。
4. 复杂性增加：管理和优化索引需要额外的工作，特别是在处理复杂查询和大量数据时。
5. 可能导致查询计划不佳：有时，数据库优化器可能会选择不合适的索引，导致查询性能下降。
6. 锁定问题：在某些情况下，索引可能会导致更多的锁定冲突，影响并发性能。

## MySQL索引类型有哪些

1. B树索引：这是MySQL中最基本的索引类型，采用B树结构存储数据，适用于查找单个值的场景。
2. B+树索引：B+树是B树的一种变体，在B树的基础上增加了叶子结点的指针。形成一个链表，适用于范围查找和排序的场景。
3. 哈希索引：这种索引采用哈希算法来快速定位数据，适用于等值查询场景，但不支持范围查询和排序。
4. 全文索引：这种索引用于全文搜索，适用于对文本进行模糊匹配和搜索的场景。

## 哪些情况适合创建索引

1. 字段的数值有唯一性的限制

::: tip
业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。
(来源:Alibaba) 说明:不要以为唯一索引影响了 insert 速度，
这个速度损耗可以忽略，但提高查找速度是明显的。
:::

2. 频繁作为 WHERE 查询条件的字段
3. DISTINCT 字段需要创建索引
4. UPDATE、DELETE 的 WHERE 条件列

::: tip
对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据
WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更
新不需要对索引进行维护。
:::

5. 多表 JOIN 连接操作时，创建索引注意事项

::: tip
连接表的数量尽量不要超过 3 张
对 WHERE 条件创建索引
对用于连接的字段创建索引 ，并且该字段在多张表中的 类型必须一致 。
:::

6. 使用最频繁的列放到联合索引的左侧
7. 在多个字段都要创建索引的情况下，联合索引优于单值索引

::: tip
联合索引（Composite Index）最左前缀原则是指在使用联合索引时，查询条件必须包含索引中定义的最左边的列，才能有效利用该索引。
换句话说，只有当查询条件中包含联合索引的最左边列或其前缀时，数据库才能使用该索引来加速查询。

假设有一个联合索引：CREATE INDEX idx_name ON users(first_name, last_name, age);

最左前缀原则:
- 完整前缀：查询条件包含first_name、last_name和age，索引可以被有效利用。
- 部分前缀：查询条件包含first_name和last_name，索引仍然可以被有效利用。
- 最左前缀：查询条件只包含first_name，索引可以被部分利用。

不符合最左前缀原则
- 跳过前缀：查询条件不包含first_name，而只包含last_name或age，索引将无法被有效利用。
- 倒序前缀：查询条件包含last_name和first_name，索引将无法被有效利用。
  在这些情况下，数据库可能会进行全表扫描，因为查询条件不符合最左前缀原则。
:::


## 什么时候不要使用索引

1. 小表：表的数据量很小，扫描全表的速度比使用索引更快。
```markdown
在数据表中的数据行数比较少的情况下，比如不到 1000 行，是不需要创建索引的。在数据量不大的情况下，索引就发挥不出作用了。
```
2. 频繁更新的列：索引会增加插入、删除和更新操作的时间，因为每次操作都需要维护索引。
3. 低选择性列：例如性别、布尔值等，索引的效果不明显，因为这些列的重复值太多。
```markdown
举例1:要在 100 万行数据中查找其中的 50 万行(比如性别为男的数据)，一旦创建了索引，你需要先
访问 50 万次索引，然后再访问 50 万次数据表，这样加起来的开销比不使用索引可能还要大。
```
4. 复合索引的非首列：在复合索引中，如果查询条件不包含索引的首列，索引将不会被使用。
5. 频繁的批量操作：例如批量插入或删除数据时，索引会导致性能下降。
6. 避免对那些定义为 text 或者 image 的列创建索引
7. 不要定义冗余或重复的索引


## 数据库sql优化

1. 优化查询语句:
    - 选择合适的字段：只查询需要的字段，避免使用SELECT *。
    - 使用合适的条件：确保WHERE子句中的条件能有效利用索引。
    - 避免在WHERE子句中对字段进行函数操作：这样做会导致索引失效。
    - 合理使用JOIN：尽量避免笛卡尔积的产生，确保JOIN的表之间有正确的索引支持。
    - 使用子查询或临时表：对于复杂的查询，适当使用子查询或创建临时表可以提高效率。

2. 索引优化:
    - 创建有效的索引：根据查询中的WHERE子句和ORDER BY子句来创建索引。
    - 避免过多索引：索引虽好，但过多则会影响写操作的性能。
    - 使用覆盖索引：尽可能让索引包含所有需要查询的字段，这样可以直接从索引中获取数据，不需要回表。

::: tip
在MySQL中，"回表"是指在使用索引进行查询时，数据库首先通过索引找到了需要的行的索引键值，但是由于查询的列并不完全包含在索引中，数据库需要再次通过索引中的指针回到数据表中检索完整的行数据。
这个过程称为“回表”。
如果查询的列完全包含在索引中，则不需要回表，直接从索引中获取数据，这个过程称为“覆盖索引”。
使用覆盖索引可以减少回表次数，提高查询效率。

回表通常发生在以下几种情况：

- 使用非覆盖索引：当索引不是覆盖索引（即索引不包含查询所需的所有字段）时，数据库需要通过索引找到行的位置，然后再到数据表中提取非索引列。
- 二级索引查询：在InnoDB存储引擎中，所有的二级索引都包含主键列作为行指针，所以当通过二级索引查询非索引列时，需要先通过二级索引找到主键，然后再通过主键回到主索引（聚簇索引）中检索完整的行数据。

非覆盖索引和二级索引区别

- 非覆盖索引关注的是索引是否能满足查询需求，即是否包含所有需要的字段。
- 二级索引关注的是索引是否基于主键，即除主键外的任何其他索引。

回表影响：

- 性能开销：回表操作会增加磁盘I/O，因为需要额外访问数据表来获取完整的行数据，这在数据量大或者查询频繁的情况下会显著影响查询性能。
- 优化策略：为了减少回表的性能损耗，可以考虑使用覆盖索引，即创建一个包含所有查询字段的索引，这样查询可以直接在索引中完成，无需回表。
  :::

3. SQL执行计划分析:
    - 查看和分析执行计划：通过执行计划可以了解SQL语句的执行过程和性能瓶颈。
    - 根据执行计划调整SQL语句或索引：根据实际的执行计划来优化SQL语句或调整索引策略。

4. 避免锁竞争:
    - 减少大事务：大事务会让持有锁的时间较长，增加锁竞争。
    - 合理设计事务：确保事务中只包含必要的操作，减少不必要的锁定。

5. 使用参数化查询:
    - 防止SQL注入：参数化查询可以有效防止SQL注入攻击。
    - 提高查询效率：参数化查询可以帮助数据库重用执行计划。

## SQL执行计划分析

使用EXPLAIN关键字可以查看SQL语句的执行计划。
EXPLAIN会返回一个结果集，其中包含SQL语句的执行计划的相关信息，包括查询的类型、是否使用索引、扫描的行数等。
通过分析EXPLAIN的结果，可以了解SQL语句的执行过程和性能瓶颈，从而进行SQL语句的优化。

例如，对于以下SQL语句：

```sql
EXPLAIN SELECT * FROM users WHERE age > 18;
```

EXPLAIN会返回以下结果集：

```
+----+-------------+-------+------------+------+---------------+--------+---------+------+------+----------+------------------------------+
| id | select_type | table | type       | possible_keys | key     | key_len | ref  | rows | Extra    |
+----+-------------+-------+------------+------+---------------+--------+---------+------+------+----------+------------------------------+
| 1  | SIMPLE      | users | const      | PRIMARY       | PRIMARY | 4       | const | 1    |         |
+----+-------------+-------+------------+------+---------------+--------+---------+------+------+----------+------------------------------+
```

通过分析EXPLAIN的结果，可以了解以下信息：

- id：SELECT的标识符。
- select_type：SELECT的类型，如SIMPLE、PRIMARY、UNION等。
- table：查询的表名。
- type：访问类型，如ALL、index、range等。
- possible_keys：可能使用的索引。
- key：实际使用的索引。
- key_len：使用的索引的长度。
- rows：扫描的行数。
- Extra：额外的信息，如Using index、Using where等。
  通过分析EXPLAIN的结果，可以了解SQL语句的执行过程和性能瓶颈，从而进行SQL语句的优化。

## DROP、DELETE与TRUNCATE的区别

- DROP：用于删除整个数据库、表或视图等对象，同时删除相关的约束、触发器和索引等。
  DROP语句是无法恢复的，一旦执行成功，对象将永久删除。
- DELETE：用于删除表中的数据行，但不删除表本身或表结构。
  DELETE语句可以使用WHERE子句指定要删除的数据行，如果没有指定WHERE子句，将删除表中的所有数据。
  DELETE语句是可逆的，使用ROLLBACK语句可以撤销删除操作。
- TRUNCATE：也是用于删除表中的数据行，与DELETE不同的是，TRUNCATE语句删除表中所有数据（不支持WHERE子句）。
  TURNCATE比DELETE更快且更有效率，同时也是无法恢复的。

DELETE语句是DML，这个操作会放到ROLLBACK SEGEMENT中，事务提交后才生效，有相应的TRIGGER。
DROP和TRUNCATE是DDL，操作立即生效，无法回滚，操作不触发TRIGGER。

DDL主要用于定义数据库的结构。
DML主要用于操作数据库中的数据。

## 内连接、左外连接、右外链接

- 内连接：只返回两个表中联结字段相等的行。
- 左外连接：返回左表中所有记录和右表中联结字段相等的记录。
- 右外连接：返回右表中所有记录和左表中联结字段相等的记录。

## 并发事务带来哪些问题

多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一条数据进行操作）。并发虽然是必须的，但是同样会导致以下几个问题

- 脏读(Dirty read)：
  当事务A正在访问数据并且对数据进行了修改，而这种修改还没有被提交到数据库中，此时事务B也访问了这个数据，然后使用了这个数据。
  因为这个数据是还没有提交的数据，那么事务B读到的数据就是脏数据，依据脏数据所做的操作可能是不正确的。

- 丢失修改(Lost to modify)：是指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务修改了这个数据后，第二个事务也修改了这个事务，那么就会导致第一个事务修改的结果被丢失，因此成为丢失修改。

- 不可重复读(Unrepeatable read)
  ：是指在一个事务内多次读取同一事务。在这个事务还没有结束时，另一个事务也访问该数据，那么在第一个事务中的两次读数据之间，由于第二个失误的修改导致第一个事务两次读取的数据可能不太一样，这就发生了在一个食物内两次读到的数据是不一样的情况，因此被称为不可重复读。

- 幻读(Phantom read)：幻读与不可重复读类似，它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，因此被称为幻读。

## 不可重复读和幻读的区别

不可重复读的重点是修改：例如多次读取一条记录，发现其中某些列的值被修改了。
幻读的重点在于新增或删除：例如多次按照固定的查询语句查询记录，发现读取到的记录数增多了或是减少了

## 单从定义上来说，可重复读隔离级别为什么会产生幻读

可重复读隔离级别主要通过锁定访问过的数据来防止数据的不一致性，但这种锁定通常只针对已经读取的具体数据记录，而不包括那些在事务执行期间新插入的数据记录。因此，它无法防止在查询范围内新增的数据，从而导致幻读现象。
总结来说，可重复读隔离级别虽然可以防止非事务期间的数据修改影响到当前事务，但它并不能处理范围内的插入或删除操作，这就是为什么它会产生幻读的原因。

## 为什么mysql的mvcc能解决幻读

MVCC（多版本并发控制）中的快照读不会产生幻读问题，但是当前读（select for update）会产生幻读问题。

## 事务隔离级别有哪些？MySQL的默认隔离级别是什么？

- 读未提交(Read uncommitted)：最低的隔离级别，一个事务可以读取另一个事务未提交的数据，容易出现脏读、不可重复读、幻读的问题。
- 读已提交(Read committed)：一个事务可以读取另一个事务提交的数据，但是可能会出现不可重复读和幻读的问题。
- 可重复读(Repeatable read)：MySQL的默认隔离级别，一个事务可以读取另一个事务提交的数据，并且可以重复读取，但是可能会出现幻读的问题。
- 串行化(Serializable)：最高的隔离级别，所有事务按照顺序依次执行，可以避免脏读、不可重复读、幻读的问题，但是性能最差。

## 大表如何优化

1. 索引优化:
   添加合适的索引：根据查询模式添加必要的索引，减少全表扫描，提高查询效率。
   优化现有索引：定期检查和优化索引，删除不必要或重复的索引，避免索引过多导致的维护成本增加。
   使用覆盖索引：尽可能使用覆盖索引，即索引包含所有查询所需的字段，避免访问表数据。
2. 分区:
   按时间分区：对于日志表或历史数据表，可以按照时间进行分区，便于数据的维护和查询。
   按业务分区：根据业务特性，如地区、用户ID等进行分区，可以提高数据的局部性，提升查询性能。
3. 归档历史数据:
   对于不常访问的历史数据，可以进行归档处理，将其转移到低成本存储中，减少主表的数据量。
4. 表结构优化:
   字段类型优化：合理选择字段类型，避免使用过大的数据类型。
   减少冗余字段：删除不必要的字段，减少数据冗余。
   使用压缩：对表数据进行压缩，减少存储空间的占用，提高I/O效率。
5. 查询优化:
   优化SQL查询：避免复杂的关联查询，尽量使用简单的查询逻辑。
   使用缓存：对频繁查询的结果使用缓存，减少数据库的访问压力。
6. 硬件优化:
   提升硬件性能：增加更多的内存和更快的CPU，或者使用更快的存储系统，如SSD。
7. 使用读写分离:
   将查询和更新操作分离，通过主从复制将读操作分散到多个从服务器，减轻主服务器的压力。
8. 定期维护:
   定期进行数据库的维护，如表的碎片整理、更新统计信息等，保持数据库性能。

## 分库分表后，id主键如何处理

## 在MySQL中，一条查询SQL是如何执行的

- 获取连接：使用MySQL连接器连接到数据库。
- 查询缓存：key为SQL语句，value为查询结果，如果查到就直接返回。但是不建议使用此缓存，在MySQL 8.0版本中已经将查询缓存删除掉了
- 分析器：将SQL语句进行分词和语法分析，判断语法是否正确，如果语法不正确，会在这个阶段发现并报错。
- 优化器：对SQL语句进行优化，选择最优的执行计划。执行计划是指在表中查询数据的方法，包括使用哪些索引、连接表的顺序等。优化器会根据表中的索引、表大小、统计信息等因素，选择最优的执行计划。
- 执行器：根据优化器选择的执行计划执行SQL语句。执行器负责打开表，根据表的引擎定义，使用引擎提供的接口获取数据，进行筛选和计算，最终返回查询结果。

## MySQL中varchar和char的区别？varchar(10)中的30代表的含义

char是一种固定长度的字符类型，而varchar是一种可变长度的字符类型。
char类型的字段在存储时会占用固定长度的空间，而varchar类型的字段在存储时会根据实际数据的长度来占用空间。
在varchar(30)中，30表示该字段可以存储的最大字符数为10，但实际存储的字符数可能小于10。如果实际使用中存储的自付超过了10，那么MySQL将自动抛出错误。

## mysql中int(10)中 10 代表的意义

int(10)中的10表示的是显示宽度，而不是存储大小。

## 为什么SELECT COUNT(*) FROM table在InnoDB比MyISAM慢

对于MyISAM表来说，表中保存了行数的计数器，因此在执行SELECT COUNT(*) FROM table时，只需要读取计数器的值，而不需要遍历整个表，因此执行速度非常快。

但是在InnoDB中，由于数据存储的特殊性质和实现方式，没有类似于MyISAM的计数器来保存表中的行数，因此MySQL需要遍历整个表来进行计数操作。

## 什么是MVCC

MVCC（多版本并发控制）是一种数据库设计，它允许在并发环境下进行事务处理，同时保证数据的一致性和完整性。
在MVCC中，每个事务在开始时都会获得一个事务ID（Transaction ID），并且每个行记录都包含一个版本号（Row Version）。
当事务开始时，它只能看到版本号小于等于当前事务ID的数据，而不能看到版本号大于当前事务。
这样，即使多个事务同时对相同的数据进行操作，也不会发生冲突，因为每个事务只能看到自己开始时的数据版本。

## 快照读与当前读

- 快照读：在MySQL中，使用不加锁的方式进行读取操作，读取的是记录的可见版本，不会阻塞其他事务的更新操作。快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。
- 当前读：在MySQL中，使用加锁的方式进行读取操作，读取的是记录的最新版本，会阻塞其他事务的更新操作。

## MVCC可以为数据库解决什么问题

1. 可重复度：通过使用每个事物的独立版本快照来避免数据被其他并发事务修改而导致的读取不一致的问题。
2. 非阻塞读：读操作不会阻塞写操作，写操作也不会阻塞读操作。(
   在MVCC中，每个数据行都有一个版本号，当进行写操作时，会将该行的版本号递增，从而生成一个新的版本。读操作会读取指定版本号的数据行，从而实现读写分离，避免阻塞。)
3. 无锁写：MVCC使用CAS(Compare-And-Swap)操作来实现乐观锁，避免了传统锁机制的瓶颈和缺陷。
4. 避免死锁：MVCC不使用传统锁机制，避免了传统锁机制中可能发生的死锁的问题。
5. 高并发：MVCC通过提供并发事务的独立快照来保证读取的一致性，从而提高了数据库的并发性能。

## MVCC实现原理之ReadView

ReadView中主要包含4个比较重要的内容：

- `creator_trx_id` ，创建Read View 的事务 ID。
- `up_limit_id`，活跃的事务中最小的事务 ID。
- `low_limit_id`，表示生成ReadView时系统中应该分配给下一个事务的 id 值。
  low_limit_id 是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。

low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。
比如，现在有id为1，2，3这三个事务，之后id为3的事务提交了。
那么一个新的读事务在生成ReadView时，trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。

### ReadView的规则

* 如果被访问版本的trx_id属性值与ReadView中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。
* 如果被访问版本的trx_id属性值小于ReadView中的 up_limit_id 值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。
* 如果被访问版本的trx_id属性值大于或等于ReadView中的 low_limit_id 值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。
* 如果被访问版本的trx_id属性值在ReadView的 up_limit_id 和 low_limit_id 之间，那就需要判断一下trx_id属性值是不是在 trx_ids
  列表中。
    * 如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。
    * 如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。

## MVCC的实现原理

1. 首先获取事务自己的版本号，也就是事务 ID；
2. 获取 ReadView；
3. 查询得到的数据，然后与 ReadView 中的事务版本号进行比较；
4. 如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；
5. 最后返回符合规则的数据。

如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性。
依此类推，直到版本链中的最后一个版本。
如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。

InnoDB 中，MVCC 是通过 Undo Log+Read View 进行数据读取，Undo Log 保存了历史快照，而 Read View 规则帮我们判断当前版本的数据是否可见。

在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次 Read View。
此时同样的查询语句都会重新获取一次 Read View，这时如果 Read View 不同，就可能产生不可重复读或者幻读的情况。

当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的
SELECT 都会复用这个 Read View，

## MySQL数据库的锁

MySQL数据库中的锁分为共享锁(Shared Lock)和排它锁(Exclusive Lock)两种。

共享锁：也被称为读锁，允许多个事务同时读取同一份数据，但不允许任何事物对数据进行修改，找到所有共享锁都被释放。

排他锁：也被称为写锁，只允许一个事务对数据进行修改，其他事务无法读取或修改数据，直到排他锁被释放。

MySQL还支持表级锁行级锁两种粒度的锁

表级锁：是对整张表的锁，可以锁定整个表，避免其他事务对该表进行任何操作。
表级锁的优点是简单，系统开销小，适用于对表进行全局性操作；
缺点是粒度太大，会导致并发性能下降。MyISAM使用表级锁。

行级锁：是针对单个数据行的锁，只锁定需要修改的数据行，避免其他事务对该数据进行操作。
行级锁的优点是粒度小，发生冲突概率低，可以提高并发性能；
缺点是实现复杂，需要维护锁定的数据行和事务的状态，容易出现死锁。
InnoDB支持行锁（必须有索引才能实现，否则会自动锁全表，变成表级锁）

## 什么是锁升级

锁升级是指将行级锁升级为表级锁的过程。
MySQL中默认使用的是行级锁，在一些特殊情况下，需要使用表级锁，但是如果表上已经存在行级锁，就需要将行级锁升级为表级锁，从而保证数据的一致性和完整性。

锁升级一般会在以下情况发生：

当前会话需要更新的行数太多，导致获取行级锁的时间过长，从而影响系统的并发性能，此时可以将行级锁升级为表级锁。

当前会话需要执行的操作已经涉及到整张表的数据，比如对表进行TRUNCATE、DROP等操作，此时需要将行级锁升级为表级锁。

锁升级的过程是自动的，由MySQL内部的锁管理器来控制，具体实现细节可以参考MySQL的官方文档。需要注意的是，锁升级会对系统的性能产生一定的影响，因此在实际的应用中需要谨慎使用，尽量避免锁升级的情况。

## 悲观锁和乐观锁

悲观锁和乐观锁是两种常见的并发控制方式。

- 悲观锁的思想是：假设并发访问的情况下，数据很可能会被其他用户修改，因此在访问数据前就会加锁，防止其他用户对数据进行修改。
  悲观锁的实现方式一般是通过数据库的锁机制来实现的，例如行级锁、表级锁等。

乐观锁的思想是：假设并发访问的情况下，数据很少会发生冲突，因此在访问数据前不会加锁，而是通过在数据上增加版本号等机制来判断数据是否被修改。
乐观锁的实现方式一般是通过在数据表中增加一个版本号或时间戳等字段，每次修改数据时都会更新这个版本号，如果读取数据是发现版本号与预期的不一致，则说明数据已经被其他用户修改，需要重新读取数据。

## 怎样尽量避免死锁的出现

为了尽量避免死锁的出现，可以采取以下措施：

1. 固定访问顺序：确保所有事务以相同的顺序访问资源，避免循环等待。

::: tip
固定访问顺序可以避免死锁的原因是它消除了循环等待的可能性。死锁通常发生在两个或多个事务相互等待对方持有的资源，而这些资源的请求顺序不一致，导致循环等待。
通过确保所有事务以相同的顺序访问资源，可以避免这种循环等待。例如，如果所有事务都按照先访问表A再访问表B的顺序进行操作，那么就不会出现一个事务持有表A的锁等待表B，而另一个事务持有表B的锁等待表A的情况，从而避免了死锁的发生。
:::

2. 减少锁定时间：尽量缩短事务的执行时间，减少持有锁的时间。
3. 合理设计索引：使用合适的索引来减少锁定的行数，从而降低死锁的概率。

::: tip
合理设计索引可以避免死锁的原因是它减少了锁定的行数和范围，从而降低了锁冲突的概率。具体来说：

1. 减少锁定范围：索引可以使查询更精确，从而只锁定必要的行，而不是整个表或大量的行。这减少了锁的竞争。
2. 提高查询效率：索引使查询更快完成，从而缩短了事务持有锁的时间，减少了锁等待的时间窗口。
3. 避免表扫描：没有索引时，查询可能需要进行全表扫描，导致大量行被锁定。索引可以避免这种情况。
   通过合理设计索引，可以显著减少锁冲突和锁等待，从而降低死锁发生的概率。
   :::

4. 分解大事务：将大事务分解为多个小事务，减少锁的竞争。
5. 使用合适的隔离级别：根据业务需求选择合适的隔离级别，避免不必要的锁定。

::: tip
使用合适的隔离级别可以避免死锁的原因是不同的隔离级别对事务的并发控制和锁的使用方式不同。选择合适的隔离级别可以减少锁的争用和冲突，从而降低死锁的概率。具体来说：

1. 读未提交（Read Uncommitted）：几乎不使用锁，但可能导致脏读，不适合大多数应用。
2. 读已提交（Read Committed）：只锁定当前读取的行，减少了锁的持有时间和范围，降低了死锁的可能性。
3. 可重复读（Repeatable Read）：使用多版本并发控制（MVCC），避免了幻读，同时减少了锁的争用。
4. 串行化（Serializable）：虽然完全避免了并发问题，但由于锁定了更多的资源，可能会增加死锁的概率。
   通过选择合适的隔离级别，可以在保证数据一致性的前提下，减少锁的争用和冲突，从而降低死锁的发生概率。
   :::

6. 检测和重试：在应用程序中捕获死锁异常，并进行重试操作。
   通过这些方法，可以有效减少死锁的发生概率。
